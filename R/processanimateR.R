#' @title Animate cases on a process map
#'
#' @description A function for creating a SVG animation of an event log on a process map created by processmapR.
#' @param eventlog The event log object that should be animated
#' @param processmap The process map created with processmapR that the event log should be animated on,
#'  if not provided a standard process map will be generated by using processmapR::process_map.
#' @param animation_mode Whether to animate the cases according to their actual time of occurence ("absolute") or to start all cases at once ("relative").
#' @param animation_duration The overall duration of the animation, all times are scaled according to this overall duration.
#' @param animation_jitter The magnitude of a random coordinate translation, known as jitter in scatterplots, which is added to each token. Adding jitter can help to disambiguate tokens traveling on top of each other.
#' @param animation_timeline Whether to render a timeline slider in supported browsers (Recent versions of Chrome and Firefox only).
#' @param animation_legend Whether to show a legend for the 'size' or the 'color' scale.
#' @param token_size The event attribute (character) or alternatively a data frame with three columns (case, time, size) matching the case identifier of the supplied event log.
#'  The token size is scaled accordingly during the animation (default size is 4). You may use \code{\link{add_token_size}} to add a suitable attribute to the event log.
#' @param token_size_scale Which D3 scale function to use for generating the size scale.
#' @param token_size_scale_domain The domain of the D3 scale function. Can be left NULL in which case it will be automatically determined.
#' @param token_size_scale_range The range of the D3 scale function. Should be a vector of two or more numerical values.
#' @param token_color The event attribute (character) or alternatively a data frame with three columns (case, time, color) matching the case identifier of the supplied event log.
#'  The token color is change accordingly during the animation (default color is orange). You may use \code{\link{add_token_color}} to add a suitable attribute to the event log.
#' @param token_color_scale Which D3 scale function to use for generating the color scale.
#' @param token_color_scale_domain The domain of the D3 scale function. Can be left NULL in which case it will be automatically determined.
#' @param token_color_scale_range The range of the D3 scale function. Should be a vector of two or more numerical values.
#' @param token_image The event attribute (character) or alternatively a data frame with three columns (case, time, image) matching the case identifier of the supplied event log.
#'  The token image is change accordingly during the animation (by default a SVG shape is used).
#' @param token_opacity The event attribute (character) or alternatively a data frame with three columns (case, time, transparency) matching the case identifier of the supplied event log.
#'  The token fill-opacity is change accordingly during the animation (by default the token is drawn with 0.9 opacity).
#' @param token_shape The (fixed) SVG shape to be used to draw tokens. Can be either 'circle' (default), 'rect' or 'image'. In the latter case the image URL needs to be specified as parameter 'token_image'.
#' @param token_attributes A list of additional (fixed) SVG attributes to be added to each token.
#' @param token_callback_onclick A javascript function that is called when a token is clicked. The function is parsed by \code{\link{JS}} and received three parameters: 'svg_root', 'svg_element', and 'case_id'.
#' @param activity_callback_onclick A javascript function that is called when an activity is clicked. The function is parsed by \code{\link{JS}} and received three parameters: 'svg_root', 'svg_element', and 'activity_id'.
#' @param elementId passed through to \code{\link{createWidget}}. A custom elementId is useful to capture the selection events via input$elementId_tokens and input$elementId_activities when used in Shiny.
#' @param preRenderHook passed through to \code{\link{createWidget}}.
#' @param width,height Fixed size for widget (in css units). The default is NULL, which results in intelligent automatic sizing based on the widget's container.
#' @param ... Options passed on to \code{\link{process_map}}.
#'
#' @examples
#' # Create small example event log
#' library(bupaR)
#' example_log <- bupaR::eventlog(
#'                  eventlog = data.frame(
#'                    case = c(rep(1,6),rep(2,6),rep(3,8)),
#'                    act = c(rep(c("A","A","B","B","C","C"),2),
#'                            rep(c("A", "B", "D", "C"), each = 2)),
#'                    act_id = rep(c(1:10),each=2),
#'                    lifecycle = rep(c("start", "complete"),10),
#'                    res = rep(sample(LETTERS[1:3], 10, replace = TRUE), each = 2),
#'                    time = as.POSIXct(c(0,5,10,15,20,25,
#'                                        5,10,15,20,25,30,
#'                                        10,20,30,40,50,60,70,80) * 600, origin = "2018/10/03")),
#'                  case_id = "case",
#'                  activity_id = "act",
#'                  timestamp = "time",
#'                  activity_instance_id = "act_id",
#'                  lifecycle_id = "lifecycle",
#'                  resource_id = "res")
#'
#' # Animate the process with default options (absolute time and 60s duration)
#' animate_process(example_log)
#'
#' \donttest{
#' # Animate the process with default options (relative time and with jitter)
#' animate_process(example_log, animation_mode = "relative", animation_jitter = 10)
#'
#' # Change default token sizes
#' animate_process(example_log, token_size = 2)
#'
#' # Change default token color
#' animate_process(example_log, token_color = "red")
#'
#' # Change default token opacity
#' animate_process(example_log, token_opacity = 0.5)
#'
#' # Change default token image (GIFs work too)
#' animate_process(example_log, token_shape = "image", token_size = 10,
#'                 token_image = "https://upload.wikimedia.org/wikipedia/en/5/5f/Pacman.gif")
#'
#' # Change token color based on a factor attribute
#' animate_process(example_log,
#'                 animation_legend = "color", token_color = "res",
#'                 token_color_scale = "ordinal",
#'                 token_color_scale_range = RColorBrewer::brewer.pal(8, "Paired"))
#'
#' # This requires example data
#' library(eventdataR)
#' data(traffic_fines)
#' # Change token color based on a numeric attribute, here the nonsensical 'time' of an event
#' animate_process(edeaR::filter_trace_frequency(bupaR::sample_n(traffic_fines,1000),percentage=0.95),
#'                animation_legend = "color", token_color = "amount",
#'                token_color_scale = "linear", token_color_scale_range = c("yellow","red"),
#'                animation_mode = "relative")
#' }
#'
#' @author Felix Mannhardt <felix.mannhardt@sintef.no> (SINTEF Digital)
#' @seealso processmapR:process_map
#'
#' @import dplyr
#' @import bupaR
#' @import processmapR
#' @importFrom magrittr %>%
#' @importFrom rlang :=
#' @importFrom rlang !!
#'
#' @export
animate_process <- function(eventlog,
                            processmap = process_map(eventlog, render = F, ...),
                            animation_mode = c("absolute","relative","off"),
                            animation_duration = 60,
                            animation_jitter = 0,
                            animation_timeline = TRUE,
                            animation_legend = NULL,
                            token_size = NULL,
                            token_size_scale = c("identity", "linear", "sqrt", "log", "quantize", "ordinal", "time"),
                            token_size_scale_domain = NULL,
                            token_size_scale_range = NULL,
                            token_color = NULL,
                            token_color_scale = c("identity", "linear", "sqrt", "log", "quantize", "ordinal", "time"),
                            token_color_scale_domain = NULL,
                            token_color_scale_range = NULL,
                            token_image = NULL,
                            token_opacity = NULL,
                            token_shape = c("circle","rect","image"),
                            token_attributes = NULL,
                            token_callback_onclick = c("function(svg_root, svg_element, case_id) {",
                                                        "}"),
                            activity_callback_onclick = c("function(svg_root, svg_element, activity_id) {",
                                                        "}"),
                            elementId = NULL,
                            preRenderHook = NULL,
                            width = NULL,
                            height = NULL,
                            ...) {

  # Make CRAN happy about dplyr evaluation
  case_start <- log_end <- start_time <- end_time <- next_end_time <- next_start_time <- NULL
  case <- case_end <- log_start <- log_duration <- case_duration <- NULL
  from_id <- to_id <- NULL
  label <- NULL
  act <- NULL

  animation_mode <- match.arg(animation_mode)
  token_shape <- match.arg(token_shape)
  token_size_scale <- match.arg(token_size_scale)
  token_color_scale <- match.arg(token_color_scale)

  # Generate the DOT source
  graph <- DiagrammeR::render_graph(processmap, width = width, height = height)
  diagram <- graph$x$diagram

  precedence <- attr(processmap, "base_precedence") %>%
    mutate_at(vars(start_time, end_time, next_start_time, next_end_time), as.numeric, units = "secs")

  if (animation_mode != "off") {

    cases <- precedence %>%
      group_by(case) %>%
      filter(!is.na(case)) %>%
      summarise(case_start = min(start_time, na.rm = T),
                case_end = max(end_time, na.rm = T)) %>%
      mutate(case_duration = case_end - case_start) %>%
      ungroup()

    # determine animation factor based on requested duration
    if (animation_mode == "absolute") {
      timeline_start <- cases %>% pull(case_start) %>% min(na.rm = T)
      timeline_end <- cases %>% pull(case_end) %>% max()
      animation_factor <- (timeline_end - timeline_start) / animation_duration
    } else {
      timeline_start <- 0
      timeline_end <- cases %>% pull(case_duration) %>% max(na.rm = T)
      animation_factor =  timeline_end / animation_duration
    }

    sizes <- generate_animation_attribute(eventlog, "size", token_size, 6)
    sizes <- transform_time(sizes, "size", cases, animation_mode, animation_factor, timeline_start, timeline_end)

    colors <- generate_animation_attribute(eventlog, "color", token_color, "white")
    colors <- transform_time(colors, "color", cases, animation_mode, animation_factor, timeline_start, timeline_end)

    images <- generate_animation_attribute(eventlog, "image", token_image, NA)
    images <- transform_time(images, "image", cases, animation_mode, animation_factor, timeline_start, timeline_end)

    if (token_shape == "image" && nrow(images) == 0) {
      stop("Need to supply image URLs in parameter 'token_images' to use shape 'image'.");
    }

    opacities <- generate_animation_attribute(eventlog, "opacity", token_opacity, 0.9)
    opacities <- transform_time(opacities, "opacity", cases, animation_mode, animation_factor, timeline_start, timeline_end)

    tokens <- generate_tokens(cases, precedence, processmap, animation_mode, animation_factor, timeline_start, timeline_end)

  } else {
    # No animation mode, for using activity selection features only
    sizes <- data.frame()
    colors <- data.frame()
    images <- data.frame()
    opacities <- data.frame()
    tokens <- data.frame()
    timeline_start <- 0
    timeline_end <- 0
    animation_timeline <- FALSE
    animation_factor <- 0

  }

  start_activity <- processmap$nodes_df %>% filter(label == "Start") %>% pull(id)
  end_activity <- processmap$nodes_df %>% filter(label == "End") %>% pull(id)
  activities <- precedence %>% select(act, id = from_id) %>% stats::na.omit() %>% distinct() %>% arrange(id)

  settings <- list()
  x <- list(
    diagram = diagram,
    activities = activities,
    tokens = tokens,
    sizes = sizes,
    sizes_scale = token_size_scale,
    sizes_scale_domain = token_size_scale_domain,
    sizes_scale_range = token_size_scale_range,
    colors = colors,
    colors_scale = token_color_scale,
    colors_scale_domain = token_color_scale_domain,
    colors_scale_range = token_color_scale_range,
    opacities = opacities,
    attributes = token_attributes,
    images = images,
    shape = token_shape,
    start_activity = start_activity,
    end_activity = end_activity,
    duration = animation_duration,
    timeline = animation_timeline,
    mode = animation_mode,
    jitter = animation_jitter,
    factor = animation_factor * 1000,
    legend = animation_legend,
    timeline_start = timeline_start * 1000,
    timeline_end = timeline_end * 1000,
    onclick_token_callback = htmlwidgets::JS(token_callback_onclick),
    onclick_activity_callback = htmlwidgets::JS(activity_callback_onclick)
  )

  htmlwidgets::createWidget(elementId = elementId,
                            name = "processanimateR", x = x,
                            width = width, height = height,
                            sizingPolicy = htmlwidgets::sizingPolicy(
                              defaultWidth = 800,
                              defaultHeight = 600,
                              browser.fill = TRUE
                            ),
                            preRenderHook = preRenderHook)
}

#' @title Create a process animation output element
#' @description Renders a renderProcessanimater within an application page.
#' @param outputId Output variable to read the animation from
#' @param width,height Must be a valid CSS unit (like 100%, 400px, auto) or a number,
#'  which will be coerced to a string and have px appended.
#'
#' @export
processanimaterOutput <- function(outputId, width = "100%", height = "400px") {
  htmlwidgets::shinyWidgetOutput(outputId = outputId,
                                 name = "processanimateR",
                                 inline = F,
                                 width = width, height = height,
                                 package = "processanimateR")
}

#' @title Renders process animation output
#' @description Renders a SVG process animation suitable to be used by processanimaterOutput.
#' @param expr The expression generating a process animation (animate_process).
#' @param env The environment in which to evaluate expr.
#' @param quoted Is expr a quoted expression (with quote())? This is useful if you want to save an expression in a variable.
#'
#' @export
renderProcessanimater <- function(expr, env = parent.frame(), quoted = FALSE) {
  if (!quoted) { expr <- substitute(expr) } # force quoted
  htmlwidgets::shinyRenderWidget(expr, processanimaterOutput, env, quoted = TRUE)
}

#
# Private helper functions
#

generate_tokens <- function(cases, precedence, processmap, animation_mode, animation_factor, timeline_start, timeline_end) {

  case <- end_time <- start_time <- next_end_time <- next_start_time <- case_start <- token_duration <- NULL
  min_order <- token_start <- activity_duration <- token_end <- from_id <- to_id <- case_duration <- NULL

  tokens <- precedence %>%
    left_join(cases, by = c("case")) %>%
    left_join(processmap$edges_df, by = c("from_id" = "from", "to_id" = "to")) %>%
    filter(!is.na(id) & !is.na(case))

  # SVG animations seem to not like events starting at the same time caused by 0s durations
  EPSILON = 0.00001

  if (animation_mode == "absolute") {
    tokens <- mutate(tokens,
                     token_start = (end_time - timeline_start) / animation_factor,
                     token_duration = (next_start_time - end_time) / animation_factor,
                     activity_duration = pmax(0, (next_end_time - next_start_time) / animation_factor))
  } else {
    tokens <- mutate(tokens,
                     token_start = (end_time - case_start) / animation_factor,
                     token_duration = (next_start_time - end_time) / animation_factor,
                     activity_duration = pmax(0, (next_end_time - next_start_time) / animation_factor))
  }

  tokens <- tokens %>%
    # Filter all negative durations caused by parallelism (TODO, deal with it in a better way)
    # Also, SMIL does not like 0 duration animateMotion
    filter(token_duration >= 0, activity_duration >= 0) %>%
    mutate(token_duration = EPSILON + token_duration,
           activity_duration = EPSILON + activity_duration) %>%
    arrange(case, start_time, min_order) %>%
    group_by(case) %>%
    # Ensure start times are not overlapping SMIL does not fancy this
    mutate(token_start = token_start + ((row_number(token_start) - min_rank(token_start)) * EPSILON)) %>%
    # Ensure consecutive start times
    mutate(token_end = min(token_start) + cumsum(token_duration + activity_duration) + EPSILON) %>%
    mutate(token_start = lag(token_end, default = min(token_start))) %>%
    # Adjust case duration
    mutate(case_duration = max(token_end)) %>%
    ungroup()

  tokens %>%
    select(case,
           edge_id = id,
           token_start,
           token_duration,
           activity_duration)

}

generate_animation_attribute <- function(eventlog, attributeName, value, default) {
  attribute <- rlang::sym(attributeName)
  if (is.null(value)) {
    # use default
    eventlog %>%
      as.data.frame() %>%
      mutate(!!attribute := default) %>%
      select(case = !!case_id_(eventlog),
             time = !!timestamp_(eventlog),
             !!attribute)
  } else if (is.data.frame(value)) {
    # check data present
    stopifnot(c("case", "time", attributeName) %in% colnames(value))
    value
  } else if (value %in% colnames(eventlog)) {
    # use existing value from event log
    eventlog %>%
      as.data.frame() %>%
      mutate(!!attribute := !!rlang::sym(value)) %>%
      select(case = !!case_id_(eventlog),
             time = !!timestamp_(eventlog),
             !!attribute)

  } else {
    # set to a fixed value
    eventlog %>%
      as.data.frame() %>%
      mutate(!!attribute := value) %>%
      select(case = !!case_id_(eventlog),
             time = !!timestamp_(eventlog),
             !!attribute)
  }
}

transform_time <- function(data, col, cases, animation_mode, animation_factor, timeline_start, timeline_end) {

  .order <- time <- case <- log_start <- case_start <- NULL

  col <- rlang::sym(col)
  data <- data %>%
    group_by(case) %>%
    filter(row_number(!!col) == 1 | lag(!!col) != !!col) %>% # only keep changes in value
    left_join(cases, by = "case")

  if (animation_mode == "absolute") {
    data <- data %>%
      mutate(time = as.numeric(time - timeline_start, units = "secs") / animation_factor) %>%
      select(case, time, !!col)
  } else {
    col <- data %>%
      mutate(time = as.numeric(time - case_start, units = "secs") / animation_factor) %>%
      select(case, time, !!col)
  }

}

# Utility functions
# https://github.com/gertjanssenswillen/processmapR/blob/master/R/utils.R
case_id_ <- function(eventlog) rlang::sym(case_id(eventlog))
timestamp_ <- function(eventlog) rlang::sym(timestamp(eventlog))
